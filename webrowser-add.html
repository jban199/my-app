<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=overlays-content">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TKA - Webrowser-Add</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="favicon.ico" sizes="any">
    <meta name="theme-color" content="#1A1A1A">

    <!-- Link to the stylesheet -->
    <link rel="stylesheet" href="styles.css">

</head>
<body>


<!-- ///////////////// -->
<!-- Add Link Modal -->
<!-- ///////////////// -->
<section id="ts-add-link-modal">
	<div class="ts-add-link-modal-header">
		<button id="ts-add-link-modal-back-btn" onclick="closeAddLink()">
			<svg height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
				<path d="m313-440 196 196q12 12 11.5 28T508-188q-12 11-28 11.5T452-188L188-452q-6-6-8.5-13t-2.5-15q0-8 2.5-15t8.5-13l264-264q11-11 27.5-11t28.5 11q12 12 12 28.5T508-715L313-520h447q17 0 28.5 11.5T800-480q0 17-11.5 28.5T760-440H313Z"/>
			</svg>
		</button>
		Add Link
	</div>
	<div class="ts-add-link-modal-body">
		
		<label for="ts-add-link-name">Name</label>
		<input type="text" id="ts-add-link-name" placeholder="Example.com">
		
		<label for="ts-add-link-url">Address</label>
		<input type="text" id="ts-add-link-url" placeholder="https://www.example.com">
		
		<label for="ts-add-link-img">Image URL (optional)</label>
		<input type="text" id="ts-add-link-img" placeholder="Image link">
	</div>
	<div class="ts-add-link-modal-footer">
		<button id="ts-add-link-modal-cancel-btn" onclick="closeAddLink()">Cancel</button>
		<button id="ts-add-link-modal-save-btn">Save</button>
	</div>
	
	<script>
	
	
	function closeAddLink() {
		location.replace('webrowser.html'); // full reload
	  }
	  

	
	// Link Management Module
let webDb;
const webDbName = "TAKAppDB";
const webStoreName = "CustomSites";
let currentEditingLinkId = null;

const webOpenRequest = indexedDB.open(webDbName);

webOpenRequest.onupgradeneeded = (e) => {
  webDb = e.target.result;
  const objectStore = webDb.createObjectStore(webStoreName, { 
    keyPath: "id", 
    autoIncrement: true 
  });
  
  objectStore.createIndex("name", "name", { unique: false });
  objectStore.createIndex("url", "url", { unique: false });
  objectStore.createIndex("img", "img", { unique: false });
  objectStore.createIndex("position", "position", { unique: false });
};

webOpenRequest.onsuccess = (e) => {
  webDb = e.target.result;
};

webOpenRequest.onerror = (e) => {
  console.error("Error opening IndexedDB", e);
  showWebSnackbar("Error opening database");
};

// Save link function
function saveLink() {
  const name = document.getElementById("ts-add-link-name").value.trim();
  const url = document.getElementById("ts-add-link-url").value.trim();
  const img = document.getElementById("ts-add-link-img").value.trim();

  if (!name || !url) {
    showWebSnackbar("Name and Address are required");
    return;
  }

  // Basic URL validation
  if (!isValidUrl(url)) {
    showWebSnackbar("Please enter a valid URL (include http:// or https://)");
    return;
  }

  const transaction = webDb.transaction([webStoreName], "readwrite");
  const store = transaction.objectStore(webStoreName);

  // Get current count to set position (for future reordering)
  const countRequest = store.count();
  
  countRequest.onsuccess = () => {
    const linkData = { 
      name, 
      url: formatUrl(url),
      img,
      position: countRequest.result // This will be the next available position
    };

    if (currentEditingLinkId !== null) {
      // For editing, keep the same position
      linkData.id = currentEditingLinkId;
      store.put(linkData);
      currentEditingLinkId = null;
      showWebSnackbar("Link updated");
    } else {
      store.add(linkData);
      showWebSnackbar("Link saved");
    }

    transaction.oncomplete = () => {
      closeAddLink();
      clearLinkForm();

    };

    transaction.onerror = (e) => {
      console.error("Error saving link", e);
      showWebSnackbar("Error saving link");
    };
  };
}

// Helper function to validate URLs
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Helper function to format URLs (ensure they have http/https)
function formatUrl(url) {
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    return 'https://' + url;
  }
  return url;
}

// Clear the link form
function clearLinkForm() {
  document.getElementById("ts-add-link-name").value = "";
  document.getElementById("ts-add-link-url").value = "";
  document.getElementById("ts-add-link-img").value = "";
}

// Initialize the save button
document.addEventListener('DOMContentLoaded', () => {
  const saveBtn = document.getElementById("ts-add-link-modal-save-btn");
  if (saveBtn) {
    saveBtn.addEventListener('click', saveLink);
  }
});

// Modified openAddLinkModal function to handle editing
function openAddLinkModal(linkData = null) {
  const modal = document.getElementById('ts-add-link-modal');
  if (modal) {
    if (linkData) {
      // Editing existing link
      currentEditingLinkId = linkData.id;
      document.getElementById("ts-add-link-name").value = linkData.name;
      document.getElementById("ts-add-link-url").value = linkData.url;
      document.getElementById("ts-add-link-img").value = linkData.img || "";
    } else {
      // Adding new link
      currentEditingLinkId = null;
      clearLinkForm();
    }
    modal.style.display = 'block';
  }
}
	
	</script>
</section>





<!-- Snackbar (hidden initially) -->
	<div id="web-snackbar" class="web-snackbar">Copied!</div>

<script>
// Snackbar function
function showWebSnackbar(message = "Copied!") {
  const snackbar = document.getElementById("web-snackbar");
  snackbar.textContent = message;
  snackbar.style.display = "block";
  snackbar.style.opacity = "1";

  setTimeout(() => {
    snackbar.style.opacity = "0";
    setTimeout(() => {
      snackbar.style.display = "none";
    }, 300);
  }, 2000);
}
</script>





<!-- ///////////////// -->
<!-- Set Theme - Based on Local Storage -->
<!-- ///////////////// -->
<script>
  // Wait for the DOM to be fully loaded before running the script
  document.addEventListener("DOMContentLoaded", function() {
    const themeLink = document.createElement("link");
    themeLink.rel = "stylesheet";
    themeLink.id = "theme-link";
    
    // Check if a theme preference is saved in localStorage
    const savedTheme = localStorage.getItem("theme");

    if (savedTheme === "dark") {
      themeLink.href = "dark-theme.css";  // If dark theme is saved, load dark-theme.css
    } else if (savedTheme === "light") {
      themeLink.href = "light-theme.css"; // If light theme is saved, load light-theme.css
    } else {
      themeLink.href = "dark-theme.css";  // Default to dark theme if no preference is saved
      localStorage.setItem('theme', 'dark');  // Save preference
    }

    // Append the theme <link> tag to the <head> of the document
    document.head.appendChild(themeLink);

    // Initialize icons based on saved theme preference
    const darkIcon = document.getElementById('dark-icon');
    const lightIcon = document.getElementById('light-icon');

    if (savedTheme === "dark") {
      lightIcon.style.display = 'none';
      darkIcon.style.display = 'block';
    } else {
      lightIcon.style.display = 'block';
      darkIcon.style.display = 'none';
    }

    // Toggle theme when button is clicked
    const themeToggleButton = document.getElementById('theme-toggle');

    themeToggleButton.addEventListener('click', () => {
      const currentTheme = themeLink.href.includes('dark-theme.css') ? 'dark' : 'light';
      if (currentTheme === 'dark') {
        themeLink.href = 'light-theme.css';  // Switch to light theme
        localStorage.setItem('theme', 'light');  // Save preference
        lightIcon.style.display = 'block';  // Show light icon
        darkIcon.style.display = 'none';   // Hide dark icon
      } else {
        themeLink.href = 'dark-theme.css';   // Switch to dark theme
        localStorage.setItem('theme', 'dark');  // Save preference
        lightIcon.style.display = 'none';   // Hide light icon
        darkIcon.style.display = 'block';   // Show dark icon
      }
    });
  });
</script>

<!-- ///////////////// -->
<!-- Prevent Right Click Context Menu -->
<!-- ///////////////// -->
<script>
  document.addEventListener('contextmenu', function(event) {
    const target = event.target;

    // Allow default context menu on input, textarea, or contenteditable elements
    if (
      target.tagName === 'INPUT' ||
      target.tagName === 'TEXTAREA' ||
      target.isContentEditable
    ) {
      return; // allow context menu
    }

    event.preventDefault(); // otherwise, block it
  });
</script>


</body>
</html>
