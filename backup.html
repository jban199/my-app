	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=overlays-content">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>TKA - Backup</title>

		<!-- PWA Meta Tags -->
		<link rel="manifest" href="manifest.json">
		<link rel="icon" href="favicon.ico" sizes="any">
		<meta name="theme-color" content="#1A1A1A">

		<!-- Link to the stylesheet -->
		<link rel="stylesheet" href="styles.css">

	</head>
	<body>


<section id="tak-page-loader">
	<div class="tak-spinner"></div>
	<p>Loading...</p>
	
	<script>
		window.addEventListener('load', function () {
			const loader = document.getElementById('tak-page-loader');
			if (loader) {
				loader.classList.add('fade-out');
				setTimeout(() => {
					loader.style.display = 'none';
				}, 500); // match the CSS transition duration (0.5s)
			}
		});
	</script>
</section>


<section class="tak-header">
	<h1 class="tak-pagename"> Backup & Restore </h1>
</section>
	

<section class="bkup-container">
    <div class="bkup-container-description">
        <svg class="bkup-container-icons" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
            <path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h447q16 0 30.5 6t25.5 17l114 114q11 11 17 25.5t6 30.5v447q0 33-23.5 56.5T760-120H200Zm280-120q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35ZM280-560h280q17 0 28.5-11.5T600-600v-80q0-17-11.5-28.5T560-720H280q-17 0-28.5 11.5T240-680v80q0 17 11.5 28.5T280-560Z"/>
        </svg>
        Backup
    </div>
    <textarea id="backupOutput" class="bkup-Display" placeholder="Your backup data will appear here..."></textarea>
    <svg class="bkup-Display-drag-handle-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
        <path d="m480-313 156-155q11-11 27.5-11.5T692-468q11 11 11 28t-11 28L508-228q-6 6-13 8.5t-15 2.5q-8 0-15-2.5t-13-8.5L268-412q-11-11-11.5-27.5T268-468q11-11 28-11t28 11l156 155Zm0-240 156-155q11-11 27.5-11.5T692-708q11 11 11 28t-11 28L508-468q-6 6-13 8.5t-15 2.5q-8 0-15-2.5t-13-8.5L268-652q-11-11-11.5-27.5T268-708q11-11 28-11t28 11l156 155Z"></path>
    </svg>
    <p class="bkup-container-userInstruction">
        Take backup of your current data. Keep it some place safe so that you may restore your current data later on. 
        This app stores your data in the browser itself. They may get deleted when you clear your browser's cache, cookies.
    </p>
    <div class="bkup-container-actionBtns">
        <button id="generateBackupBtn" class="bkup-container-actionBtns-primary">Generate</button>
        <button id="clearBackupBtn" class="bkup-container-actionBtns-secondary">Clear</button>
    </div>
</section>

<section class="bkup-container">
    <div class="bkup-container-description">
        <svg class="bkup-container-icons" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
            <path d="M480-120q-138 0-240.5-91.5T122-440h82q14 104 92.5 172T480-200q117 0 198.5-81.5T760-480q0-117-81.5-198.5T480-760q-69 0-129 32t-101 88h110v80H120v-240h80v94q51-64 124.5-99T480-840q75 0 140.5 28.5t114 77q48.5 48.5 77 114T840-480q0 75-28.5 140.5t-77 114q-48.5 48.5-114 77T480-120Zm112-192L440-464v-216h80v184l128 128-56 56Z"/>
        </svg>
        Restore
    </div>
    <textarea id="restoreInput" class="bkup-Display" placeholder="Your restore data will appear here after loading a file..."></textarea>
    <svg class="bkup-Display-drag-handle-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
        <path d="m480-313 156-155q11-11 27.5-11.5T692-468q11 11 11 28t-11 28L508-228q-6 6-13 8.5t-15 2.5q-8 0-15-2.5t-13-8.5L268-412q-11-11-11.5-27.5T268-468q11-11 28-11t28 11l156 155Zm0-240 156-155q11-11 27.5-11.5T692-708q11 11 11 28t-11 28L508-468q-6 6-13 8.5t-15 2.5q-8 0-15-2.5t-13-8.5L268-652q-11-11-11.5-27.5T268-708q11-11 28-11t28 11l156 155Z"></path>
    </svg>
    <p class="bkup-container-userInstruction">
        Take backup of your current data before you Validate. This action will wipe out all your previously stored data.
    </p>
    <div class="bkup-container-actionBtns">
        <input type="file" id="uploadRestoreFile" accept=".txt,.json" class="bkup-container-actionBtns-secondary" />
        <button id="validateRestoreBtn" class="bkup-container-actionBtns-primary">Validate</button>
        <button id="clearRestoreBtn" class="bkup-container-actionBtns-secondary">Clear</button>
    </div>
</section>



<!-- Include config first -->
<script src="dbConfig.js"></script>
<script>
    // ======================
    // CONFIGURATION SECTION
    // ======================
    const DB_CONFIG = {
        name: window.ts_DB_NAME,
        version: window.ts_DB_VERSION,
        stores: [
            { name: "CustomSites", keyPath: "id", autoIncrement: true },
            { name: "UserNotes", keyPath: "id", autoIncrement: true },
            { name: "UserDocs", keyPath: "id", autoIncrement: true },
            { name: "CustomNumbers", keyPath: "id", autoIncrement: true }
        ]
    };

    // ======================
    // GLOBAL VARIABLES
    // ======================
    let dbReadyPromise;

    // ======================
    // CORE FUNCTIONS
    // ======================

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);

            request.onupgradeneeded = function(e) {
                const db = e.target.result;
                DB_CONFIG.stores.forEach(store => {
                    if (!db.objectStoreNames.contains(store.name)) {
                        db.createObjectStore(store.name, {
                            keyPath: store.keyPath,
                            autoIncrement: store.autoIncrement
                        });
                    }
                });
            };

            request.onsuccess = function(e) {
                resolve(e.target.result);
            };

            request.onerror = function(e) {
                showTakSnackbar("Database initialization failed");
                reject(e);
            };
        });
    }

    async function generateBackup() {
        const db = await dbReadyPromise;
        const output = {};
        const storeNames = DB_CONFIG.stores.map(store => store.name);
        const tx = db.transaction(storeNames, "readonly");

        const storePromises = DB_CONFIG.stores.map(store => {
            return new Promise(resolve => {
                const request = tx.objectStore(store.name).getAll();
                request.onsuccess = () => {
                    output[store.name] = request.result;
                    resolve();
                };
                request.onerror = () => {
                    showTakSnackbar(`Error reading ${store.name} data`);
                    resolve();
                };
            });
        });

        await Promise.all(storePromises);

        const jsonData = JSON.stringify(output, null, 2);

        // Put data in textarea for reference
        const backupOutput = document.getElementById("backupOutput");
        if (backupOutput) {
            backupOutput.value = jsonData;
        }

        // Generate timestamped filename: backup-YYYY-MM-DD-HH-mm.txt
        const now = new Date();
        const pad = (n) => n.toString().padStart(2, "0");
        const fileName = `backup-${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}-${pad(now.getHours())}-${pad(now.getMinutes())}.txt`;

        // Create and trigger download
        const blob = new Blob([jsonData], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showTakSnackbar(`Backup downloaded as ${fileName}`);
    }

    async function validateRestore() {
        const db = await dbReadyPromise;
        const restoreInput = document.getElementById("restoreInput");
        if (!restoreInput || !restoreInput.value.trim()) {
            showTakSnackbar("Please load backup file first");
            return;
        }

        let parsed;
        try {
            parsed = JSON.parse(restoreInput.value);
            const validStores = DB_CONFIG.stores.filter(store => parsed.hasOwnProperty(store.name));
            if (validStores.length === 0) throw new Error("Invalid backup format");
        } catch (e) {
            showTakSnackbar("Invalid backup data");
            return;
        }

        const storesToProcess = DB_CONFIG.stores.filter(store => parsed.hasOwnProperty(store.name));
        const storeNames = storesToProcess.map(store => store.name);
        const tx = db.transaction(storeNames, "readwrite");

        let successCount = 0;
        let errorCount = 0;

        storesToProcess.forEach(store => {
            const objectStore = tx.objectStore(store.name);
            const clearRequest = objectStore.clear();

            clearRequest.onsuccess = () => {
                if (Array.isArray(parsed[store.name])) {
                    parsed[store.name].forEach(item => {
                        const putRequest = objectStore.put(item);
                        putRequest.onsuccess = () => successCount++;
                        putRequest.onerror = () => errorCount++;
                    });
                }
            };

            clearRequest.onerror = () => errorCount++;
        });

        tx.oncomplete = () => {
            const restoredStores = storesToProcess.map(s => s.name).join(', ');
            if (errorCount > 0) {
                showTakSnackbar(`Restored ${restoredStores} with some errors`);
            } else {
                showTakSnackbar(`Successfully restored ${restoredStores}`);
            }
        };

        tx.onerror = () => {
            showTakSnackbar("Restoration failed");
        };
    }

    // ======================
    // HELPER FUNCTIONS
    // ======================

    // UPLOAD backup file
    function uploadRestoreFile(event) {
        const file = event.target.files[0];
        if (!file) {
            showTakSnackbar("No file selected");
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const restoreInput = document.getElementById("restoreInput");
            if (restoreInput) {
                restoreInput.value = e.target.result;
                showTakSnackbar("Backup file loaded");
            }
        };
        reader.onerror = () => {
            showTakSnackbar("Failed to read file");
        };

        reader.readAsText(file);
    }

    function clearBackup() {
        const backupOutput = document.getElementById("backupOutput");
        if (backupOutput) {
            backupOutput.value = "";
            showTakSnackbar("Backup cleared");
        }
    }

    function clearRestore() {
        const restoreInput = document.getElementById("restoreInput");
        if (restoreInput) {
            restoreInput.value = "";
            showTakSnackbar("Restore data cleared");
        }
    }

    // ======================
    // INITIALIZATION
    // ======================
    window.addEventListener("load", function() {
        dbReadyPromise = initDB();

        document.getElementById("generateBackupBtn")?.addEventListener("click", generateBackup);
        document.getElementById("clearBackupBtn")?.addEventListener("click", clearBackup);
        document.getElementById("validateRestoreBtn")?.addEventListener("click", validateRestore);
        document.getElementById("uploadRestoreFile")?.addEventListener("change", uploadRestoreFile);
        document.getElementById("clearRestoreBtn")?.addEventListener("click", clearRestore);
    });
</script>






<!-- Snackbar (hidden initially) -->
<div id="tak-snackbar" class="tak-snackbar">Welcome!</div>

<!-- Confirm Delete Dialog (hidden initially) -->
<div id="bkup-confirm-dialog" class="tak-dialog" style="display: none;">
	<div class="tak-dialog-box">
		<p>Creating backup of your current data is recommended. Click "Continue" to permanently replace your current data.</p>
		<div class="tak-dialog-actions">
			<button class="tak-dialog-skip" id="bkup-dialog-skip">Skip</button>
			<button class="tak-dialog-continue" id="bkup-dialog-continue">Continue</button>
		</div>
	</div>
</div>

<script>
// Snackbar function
function showTakSnackbar(message = "Welcome!") {
  const snackbar = document.getElementById("tak-snackbar");
  snackbar.textContent = message;
  snackbar.style.display = "block";
  snackbar.style.opacity = "1";

  setTimeout(() => {
	snackbar.style.opacity = "0";
	setTimeout(() => {
	  snackbar.style.display = "none";
	}, 300);
  }, 2000);
}
</script>



<!-- ///////////////// -->
<!-- Footer Spacer -->
<!-- ///////////////// -->
<div class="footerSpacer">
</div>


<!-- ///////////////// -->
<!-- Bottom Menu -->
<!-- ///////////////// -->
<section>
<!-- SBM Trigger -->
<svg id="SBM-Icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff">
    <path d="M86-191v-126h788v126H86Zm0-226v-126h788v126H86Zm0-226v-126h788v126H86Z"/>
</svg>

<!-- SBM container (empty, the content is injected here) -->
<div id="SBM-container"></div>
</section>


<script>
window.addEventListener("load", function () {	
    // Load SBM
    fetch('sbm.html')
        .then(response => response.text())
        .then(data => {
            const sidebarContainer = document.getElementById('SBM-container');
            sidebarContainer.innerHTML = data;

            // Make sure sidebar is hidden after load
            const overlaySBM = document.getElementById("SBM-section");
            if (overlaySBM) {
                overlaySBM.style.transform = "translateY(100%)";
            }

            // Reattach event listeners after the SBM is loaded
            const closeButton = document.getElementById("closeSBM");
            if (closeButton) {
                closeButton.addEventListener("click", closeSBM);
            }

            // Get reference to the icon that triggers the sidebar opening
            const SBMIcon = document.getElementById("SBM-Icon");

            // Function to open the sidebar
            function openSBM() {
                if (overlaySBM) {
                    overlaySBM.style.transform = "translateY(0)";
                }
            }

            // Function to close the sidebar
            function closeSBM() {
                if (overlaySBM) {
                    overlaySBM.style.transform = "translateY(100%)";
                }
            }

            // Event listener for opening the SBM when the icon is clicked
            if (SBMIcon) {
                SBMIcon.addEventListener("click", openSBM);
            }
        })
        .catch(error => {
            console.error("Error loading SBM:", error);
        });
});
</script>


<!-- ///////////////// -->
<!-- User Selected Accent Color -->
<!-- ///////////////// -->
<style id="theme-accent-style">
  :root {
	--accent1: #FD7E14; /* Default fallback accent */
  }
</style>
<script>
	(function theme_applyAccentFromStorage() {
	const savedAccent = localStorage.getItem('theme_accent');
	const accentStyle = document.getElementById('theme-accent-style');

	if (savedAccent && accentStyle) {
	  accentStyle.textContent = `:root { --accent1: ${savedAccent}; }`;
	}
	})();
</script>



<!-- ///////////////// -->
<!-- Theme Toggle -->
<!-- ///////////////// -->
<section>
<button id="theme-toggle">
    <!-- Default dark icon (SVG) -->
    <svg id="dark-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
      <path d="M480-280q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Z"/>
    </svg>

    <!-- Light Icon (hidden by default) -->
    <svg id="light-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f" style="display: none;">
      <path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Z"/>
    </svg>
</button>
</section>

<!-- ///////////////// -->
<!-- Set Theme - Based on Local Storage -->
<!-- ///////////////// -->
<script>
  // Wait for the DOM to be fully loaded before running the script
  document.addEventListener("DOMContentLoaded", function() {
    const themeLink = document.createElement("link");
    themeLink.rel = "stylesheet";
    themeLink.id = "theme-link";
    
    // Check if a theme preference is saved in localStorage
    const savedTheme = localStorage.getItem("theme");

    if (savedTheme === "dark") {
      themeLink.href = "dark-theme.css";  // If dark theme is saved, load dark-theme.css
    } else if (savedTheme === "light") {
      themeLink.href = "light-theme.css"; // If light theme is saved, load light-theme.css
    } else {
      themeLink.href = "dark-theme.css";  // Default to dark theme if no preference is saved
      localStorage.setItem('theme', 'dark');  // Save preference
    }

    // Append the theme <link> tag to the <head> of the document
    document.head.appendChild(themeLink);

    // Initialize icons based on saved theme preference
    const darkIcon = document.getElementById('dark-icon');
    const lightIcon = document.getElementById('light-icon');

    if (savedTheme === "dark") {
      lightIcon.style.display = 'none';
      darkIcon.style.display = 'block';
    } else {
      lightIcon.style.display = 'block';
      darkIcon.style.display = 'none';
    }

    // Toggle theme when button is clicked
    const themeToggleButton = document.getElementById('theme-toggle');

    themeToggleButton.addEventListener('click', () => {
      const currentTheme = themeLink.href.includes('dark-theme.css') ? 'dark' : 'light';
      if (currentTheme === 'dark') {
        themeLink.href = 'light-theme.css';  // Switch to light theme
        localStorage.setItem('theme', 'light');  // Save preference
        lightIcon.style.display = 'block';  // Show light icon
        darkIcon.style.display = 'none';   // Hide dark icon
      } else {
        themeLink.href = 'dark-theme.css';   // Switch to dark theme
        localStorage.setItem('theme', 'dark');  // Save preference
        lightIcon.style.display = 'none';   // Hide light icon
        darkIcon.style.display = 'block';   // Show dark icon
      }
    });
  });
</script>


<!-- ///////////////// -->
<!-- Fullscreen Toggle -->
<!-- ///////////////// -->
<section>
  <button id="fullscreen-toggle" class="fullscreen-button">
  <!-- Icon for entering fullscreen (initially displayed) -->
  <svg id="fullscreen-enter-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
    <path d="M86-86v-260h126v134h134v126H86Zm529 0v-126h133v-134h126v260H615ZM86-615v-259h260v126H212v133H86Zm662 0v-133H615v-126h259v259H748Z"/>
  </svg>

  <!-- Icon for exiting fullscreen (hidden initially) -->
  <svg id="fullscreen-exit-icon" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f" style="display: none;">
    <path d="M220-86v-134H86v-126h260v260H220Zm395 0v-260h259v126H741v134H615ZM86-615v-126h134v-133h126v259H86Zm529 0v-259h126v133h133v126H615Z"/>
  </svg>
</button>
</section>
<script>
  // Fullscreen Toggle Logic
const fullscreenButton = document.getElementById('fullscreen-toggle');
fullscreenButton.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.getElementById('fullscreen-enter-icon').style.display = 'none';
    document.getElementById('fullscreen-exit-icon').style.display = 'block';
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
      document.getElementById('fullscreen-enter-icon').style.display = 'block';
      document.getElementById('fullscreen-exit-icon').style.display = 'none';
    }
  }
});

</script>



<!-- ///////////////// -->
<!-- Prevent Right Click Context Menu -->
<!-- ///////////////// -->
<script>
  document.addEventListener('contextmenu', function(event) {
    const target = event.target;

    // Allow default context menu on input, textarea, or contenteditable elements
    if (
      target.tagName === 'INPUT' ||
      target.tagName === 'TEXTAREA' ||
      target.isContentEditable
    ) {
      return; // allow context menu
    }

    event.preventDefault(); // otherwise, block it
  });
</script>


<!-- ///////////////// -->
<!-- Capacitor Functions -->
<!-- ///////////////// -->
<script type="module" src="capacitorFunctions.js"></script>


</body>
</html>
