<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mobile Runner â€” ts_game</title>
  <style>
    :root{
      --bg:#0f1722; --card:#0b1220; --accent:#06b6d4; --muted:#93c5fd;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    /* Force portrait layout and show rotate hint on landscape */
    .app{height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg),#071024);color:#fff}
    .game-wrap{width:100%;max-width:420px;height:780px;border-radius:18px;overflow:hidden;background:linear-gradient(180deg,#071422, #021018);box-shadow:0 8px 30px rgba(2,6,23,.6);position:relative}

    /* Portrait-only overlay when wide */
    .landscape-mask{display:none;position:absolute;inset:0;background:rgba(0,0,0,.9);z-index:99;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:20px}
    @media (orientation:landscape){.landscape-mask{display:flex}} 

    /* HUD */
    .hud{position:absolute;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;z-index:8}
    .chip{background:rgba(255,255,255,.06);padding:8px 12px;border-radius:999px;font-weight:600;display:inline-flex;gap:8px;align-items:center}

    /* play area */
    .stage{position:absolute;inset:0;padding:40px 14px 28px 14px;display:flex;flex-direction:column;justify-content:flex-end;z-index:1}
    .ground{height:110px;position:relative}
    .ground-line{position:absolute;left:0;right:0;bottom:56px;height:6px;background:linear-gradient(90deg,#083344,#02364a);box-shadow:0 2px 6px rgba(2,6,23,.6)}

    /* player */
    .player{width:56px;height:56px;background:linear-gradient(180deg,var(--accent),#0ea5a5);border-radius:10px;position:absolute;left:68px;bottom:62px;transform-origin:center;display:flex;align-items:center;justify-content:center;font-weight:700;color:#012;box-shadow:0 8px 18px rgba(6,182,212,.18)}

    /* obstacles */
    .obstacle{position:absolute;bottom:62px;width:44px;border-radius:8px;background:linear-gradient(180deg,#7c2d14,#a16207);box-shadow:0 6px 16px rgba(0,0,0,.5)}

    /* small mobile instructions */
    .hint{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);z-index:6;background:rgba(255,255,255,.04);padding:8px 12px;border-radius:999px;font-size:13px}

    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:10}
    .panel{background:linear-gradient(180deg,rgba(4,10,20,.95),rgba(3,7,13,.95));padding:20px;border-radius:12px;backdrop-filter: blur(6px);box-shadow:0 12px 40px rgba(2,6,23,.6);text-align:center}
    .btn{display:inline-block;padding:10px 16px;border-radius:10px;background:var(--accent);color:#012;font-weight:700;border:none;font-size:16px}
    .small{font-size:13px;color:var(--muted);margin-top:8px}

    /* responsive touch area to show large button on mobile */
    .touch-pad{position:absolute;inset:0;z-index:4}
    .touch-visual{position:absolute;right:12px;bottom:92px;background:rgba(255,255,255,.03);padding:12px;border-radius:12px;font-weight:700}

    /* game-over styles */
    .game-over{display:flex;flex-direction:column;gap:12px;align-items:center}

    /* small accessibility */
    button:active{transform:translateY(1px)}
  </style>
</head>
<body>
  <div class="app">
    <div class="game-wrap" id="ts_gameWrap">
      <div class="landscape-mask"> 
        <svg width="96" height="96" viewBox="0 0 24 24" fill="none" style="opacity:.9"><path d="M12 2v20M2 12h20" stroke="#fff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <div style="color:#fff;margin-top:14px;font-weight:700">Rotate to portrait</div>
        <div style="color:#bcd;opacity:.9;margin-top:8px">This game is made for portrait (mobile) use.</div>
      </div>

      <div class="hud">
        <div class="chip">Score: <span id="ts_score">0</span></div>
        <div class="chip">High: <span id="ts_high">0</span></div>
      </div>

      <div class="stage" id="ts_stage">
        <div class="ground">
          <div class="ground-line"></div>
        </div>

        <!-- Player element -->
        <div id="ts_player" class="player">ðŸ™‚</div>

        <!-- container for obstacles (generated in JS) -->
        <div id="ts_obstacles"></div>
      </div>

      <div class="hint">Tap to jump â€¢ Double-tap for double-jump</div>

      <!-- touch pad (captures taps) -->
      <div class="touch-pad" id="ts_touchPad"></div>

      <!-- overlays -->
      <div class="overlay" id="ts_startOverlay">
        <div class="panel">
          <h2 style="margin:0 0 8px 0">Mobile Runner</h2>
          <p class="small">Portrait only â€¢ Tap to jump â€¢ Avoid obstacles</p>
          <div style="margin-top:12px">
            <button class="btn" id="ts_startBtn">Start</button>
          </div>
          <div class="small">Best experienced on mobile. Use browser "Add to Home screen" for app-like feel.</div>
        </div>
      </div>

      <div class="overlay" id="ts_gameOverOverlay" style="display:none">
        <div class="panel game-over">
          <h3 id="ts_finalScore">You scored 0</h3>
          <div style="display:flex;gap:8px">
            <button class="btn" id="ts_restartBtn">Play again</button>
            <button class="btn" id="ts_shareBtn" style="background:rgba(255,255,255,.06);color:#bfe">Share</button>
          </div>
          <div class="small" style="margin-top:6px">Tip: longer holds charge a big jump</div>
        </div>
      </div>

    </div>
  </div>

  <script>
  // Mobile Runner â€” single-file. All functions prefixed with ts_
  (function(){
    const wrap = document.getElementById('ts_gameWrap');
    const player = document.getElementById('ts_player');
    const obsContainer = document.getElementById('ts_obstacles');
    const startOverlay = document.getElementById('ts_startOverlay');
    const startBtn = document.getElementById('ts_startBtn');
    const gameOverOverlay = document.getElementById('ts_gameOverOverlay');
    const restartBtn = document.getElementById('ts_restartBtn');
    const shareBtn = document.getElementById('ts_shareBtn');
    const scoreEl = document.getElementById('ts_score');
    const highEl = document.getElementById('ts_high');
    const finalScore = document.getElementById('ts_finalScore');
    const touchPad = document.getElementById('ts_touchPad');

    // Game state
    let ts_running = false;
    let ts_score = 0;
    let ts_high = Number(localStorage.getItem('ts_runner_high')||0);
    highEl.textContent = ts_high;

    // Physics
    let y=0, vy=0; // vertical offset from ground
    const groundY = 0; // bottom position
    let canDoubleJump = true;
    let isHolding = false;
    let holdStart = 0;

    // timing
    let lastTime = 0;
    let obstacleTimer = 0;
    let spawnInterval = 1500; // ms
    let speed = 420; // pixels per second â€” increases over time

    // responsive sizes
    function ts_getStageWidth(){ return document.getElementById('ts_stage').clientWidth; }

    // helpers
    function ts_setScore(n){ ts_score = n; scoreEl.textContent = Math.floor(ts_score); }
    function ts_endGame(){
      ts_running = false;
      gameOverOverlay.style.display = 'flex';
      finalScore.textContent = 'You scored ' + Math.floor(ts_score);
      if (Math.floor(ts_score) > ts_high){ ts_high = Math.floor(ts_score); localStorage.setItem('ts_runner_high', ts_high); highEl.textContent = ts_high }
    }

    // create obstacle element
    function ts_spawnObstacle(){
      const el = document.createElement('div');
      el.className = 'obstacle';
      const h = 44 + Math.random()*36; // height variation
      el.style.height = h + 'px';
      el.style.width = (36 + Math.random()*28) + 'px';
      const startX = ts_getStageWidth() + 60;
      el.style.left = startX + 'px';
      el.dataset.x = startX;
      el.dataset.w = parseFloat(el.style.width);
      obsContainer.appendChild(el);
    }

    // basic collision check
    function ts_checkCollision(ob){
      // Use robust viewport bounding-box collision instead of manual y-math.
      // The old code double-counted the 'y' jump offset which made the player
      // appear to collide while actually above the obstacle. Using getBoundingClientRect
      // is simpler and more reliable across sizes.
      const pad = 6; // small forgiving padding so near-misses don't count
      const pr = player.getBoundingClientRect();
      const or = ob.getBoundingClientRect();

      // standard rect intersection test with padding
      if (pr.left + pad < or.right && pr.right - pad > or.left && pr.top + pad < or.bottom && pr.bottom - pad > or.top) {
        return true;
      }
      return false;
    }

    // game loop
    function ts_loop(ts){
      if (!lastTime) lastTime = ts; const dt = (ts - lastTime)/1000; lastTime = ts;
      if (!ts_running) return;

      // move obstacles
      const move = speed * dt;
      obstacleTimer += dt*1000;
      if (obstacleTimer > spawnInterval){ ts_spawnObstacle(); obstacleTimer = 0; spawnInterval = 900 + Math.random()*900 }

      // update each obstacle
      const obs = Array.from(obsContainer.children);
      for (let i=0;i<obs.length;i++){
        const el = obs[i];
        let x = parseFloat(el.dataset.x) - move;
        el.dataset.x = x;
        el.style.left = x + 'px';
        // collision
        if (ts_checkCollision(el)){
          ts_running = false; // stop physics
          ts_endGame();
          return;
        }
        if (x + parseFloat(el.dataset.w) < -60){ el.remove() }
      }

      // update physics (jump)
      // hold charging: if holding, increase vy slightly
      if (isHolding){
        const held = Math.min((performance.now()-holdStart)/400,1);
        // visual scale when holding
        player.style.transform = `translateY(${-y}px) scale(${1 - held*0.06})`;
      }

      // gravity
      vy -= 1400 * dt; // strong gravity
      y += vy * dt;
      if (y < 0){ y = 0; vy = 0; canDoubleJump = true }

      // apply transform
      player.style.bottom = (62 + y) + 'px';
      if (!isHolding) player.style.transform = `translateY(${-y}px)`;

      // score increases with time and speed
      ts_setScore(ts_score + dt * (speed/100));

      // slowly increase speed
      speed += dt * 2;

      requestAnimationFrame(ts_loop);
    }

    // jump function
    function ts_doJump(power){
      if (!ts_running) return;
      if (y === 0){ // ground jump
        vy = 680 + power*420; // initial velocity
        canDoubleJump = true;
      } else if (canDoubleJump){ // double
        vy = 480 + power*320;
        canDoubleJump = false;
      }
    }

    // input handlers
    function ts_onTap(){
      // short tap = small jump, long hold = bigger
      const held = Math.min((performance.now()-holdStart)/400,1);
      ts_doJump(held);
      isHolding = false;
    }

    // Touch management: detect tap vs hold
    let lastTap = 0;
    touchPad.addEventListener('touchstart', function(e){
      e.preventDefault();
      holdStart = performance.now();
      isHolding = true;
    },{passive:false});
    touchPad.addEventListener('touchend', function(e){
      e.preventDefault();
      const now = performance.now();
      const dt = now - lastTap;
      if (dt < 260){ // double-tap
        ts_doJump(1); // force strong jump
        lastTap = 0;
      } else {
        ts_onTap(); lastTap = now;
      }
    });

    // mouse support for desktop testing
    touchPad.addEventListener('mousedown', function(e){ e.preventDefault(); holdStart = performance.now(); isHolding = true },{passive:false});
    window.addEventListener('mouseup', function(e){ if (isHolding){ ts_onTap() } },{passive:false});

    // start / restart
    function ts_start(){
      startOverlay.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      obsContainer.innerHTML = '';
      ts_setScore(0);
      y = 0; vy = 0; speed = 420; obstacleTimer = 0; spawnInterval = 1400; lastTime = 0;
      ts_running = true;
      requestAnimationFrame(ts_loop);
    }

    startBtn.addEventListener('click', ts_start);
    restartBtn.addEventListener('click', ts_start);

    // simple share button
    shareBtn.addEventListener('click', function(){
      if (navigator.share){
        navigator.share({title:'My Mobile Runner',text:'I scored '+Math.floor(ts_score)+' in Mobile Runner',url:location.href}).catch(()=>{});
      } else { alert('Share not supported on this browser') }
    });

    // keyboard for debugging
    window.addEventListener('keydown', function(e){ if (e.code === 'Space') ts_doJump(0.6) });

    // pause when hidden
    document.addEventListener('visibilitychange', function(){ if (document.hidden) ts_running = false; });

    // autoplay mobile audio is not included â€” keep silent to avoid permission dialogs

    // expose a few things for quick tweak in console
    window.ts_game = {start: ts_start, end: ts_endGame};

  })();
  </script>
</body>
</html>
